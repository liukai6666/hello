/**
 *	本章介绍如下
 * 	理解并发
 * 	并发和并行
 * 	通过web浏览器来理解并发
 * 	阻塞和非阻塞代码
 * 	使用Goroutine处理并发操作
 * 	定义Goroutine
 *
 * 	本章介绍并发和Goroutine。您将明白顺序执行和并发执行的差别，知道Goroutine是应对网络延迟的方式之一；您将了解并发和并行的差别，知道Goroutine是如何提高程序的运行速度的。
 * 	Goroutine是最优雅的Go语言功能之一
 *
 * 	理解并发
 * 		要理解Goroutine，必须先明白并发的含义。在最简单的计算机程序中，操作是依次执行的，执行顺序与出现顺序相同。对很多编程任务而言，按顺序执行任务的理念不仅可行，而且效果很显著。
 * 		另一种理念是不必等到下一个操作执行完毕后再执行下一个，编程任务和编程环境越复杂，这种理念就越重要。提出这种理念旨在让程序能够应对更复杂的情形，避免执行完一行代码后再执行下一
 * 	行，从而提高程序的执行速度。程序完全按顺序执行时，如果某行代码需要很长时间才能执行完毕，那么整个程序将可能因此而停止，导致用户长时间等待事件的发生。
 * 		现代编程必须考虑众多时间不可预测的变数。例如，您无法确定网络调用需要多长时间才能完成，也无法确定读取磁盘文件需要多长时间。
 * 		假设程序需要从天气服务那里获取某个地方当前的天气情况时，就需要编写一些代码来执行这种请求并处理Web服务器的响应。程序发出请求后，很多因素都可能影响到响应返回的速度，如以下
 * 	几种。
 * 		查找天气服务地址的DNS的速度
 * 		程序和天气服务器之间网络连接的速度
 * 		建立与天气服务器连接的速度
 * 		天气服务器的响应速度
 * 		鉴于所有这些因素都不是发出请求的程序能够控制的，因此完全有理由认为响应速度是无法预测的。另外，每次请求得到的响应的时间都可能不同。面对这样的情形，程序员可选择等待响应--
 * 	阻塞程序直到响应返回为止，也可继续执行其他有用的任务。大多数现代编程语言都提供了选择空间，让程序员可等待响应，也可继续做其他事情。
 * 		餐厅服务员给顾客提供服务的过程，完成其中每个步骤的时间都是不确定的。
 * 		顾客需要多长时间才能入座？
 * 		顾客需要多长时间才能点好菜？
 * 		顾客需要多长时间才能下单？
 * 		厨师需要多长时间才能开始做菜？
 * 		厨师需要多长时间才能将菜做好？
 * 		如果按顺序做，服务员能够很好地为顾客服务，但无法同时为其他顾客提供服务！如果每位服务员都专一为一位顾客服务，则餐厅的收费将非常高。相反，服务员可并发地执行任务。这意味着在
 * 	厨师做菜时服务员可以给其他顾客点菜，并在其他顾客点菜期间去取菜。
 * 		随着互联网的日益普及，网络编程越来越常见：程序可能向多个服务请求信息；数据库可能位于另一个完全不同的网络中。鉴于一切都是基于网络的，要可靠地预测任务完成的时间是很难做到的。
 *
 * 	并发和并行的差别？
 * 		并发就是同时处理很多事情，而并行就是同时做很多事情（个人理解 并发：同时发生，如同一时间，单个程序被同时访问、并行：同一时间，做同一件事）
 * 	Google日常工作的并发需求是催生出Go的动力之一，因为使用传统的系统语言难以编写高效的并发代码
 *
 * 	Go使用线程来管理并发，但Goroutine让程序员无须直接管理线程，它消除了这样做的痛苦。创建一个Goroutine只需占用几个KB的内存，因此即便创建数千个Goroutine也不会耗尽内存。另外，
 * 	创建和销毁Goroutine的效率也非常高
 */
package main

import (
	"fmt"
	"time"
)

func slowFunc() {
	time.Sleep(time.Second * 2)
	fmt.Println("sleeper() finished")
}

func main() {
	//
	/**
	 *	未使用Goroutine ： 等待slowFunc()执行期间、没有执行其他代码，这些代码是阻塞的
	 * 	使用Goroutine ： 代码是非阻塞的
	 * 	你看不到slowFunc的结果？
	 * 		因为Goroutine所处代码立即返回，程序将接着执行后面的代码，执行至末尾程序将直接退出。如果此时Goroutine执行的代码未执行完，将看不到Goroutine代码的执行结果。
	 * 		解决方案：
	 * 			在程序增加休眠、阻塞程序退出、休眠时间必须大于Goroutine执行代码的时间
	 */
	go slowFunc()
	fmt.Println("I am not shown until slowFunc() completes")
	time.Sleep(time.Second * 3)

}
