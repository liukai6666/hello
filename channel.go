/**
 * 	使用通道
 * 	使用缓冲通道
 * 	阻塞和流程控制
 * 	将通道作用函数参数
 * 	使用select语句
 * 	退出通道
 *
 * 	Channel能够管理Goroutine之间的通信。通道和Goroutine一同提供了一个提供了一个受控的环境，能够让您开发并发软件
 *
 * 	如果说Goroutine是一种支持并发编程的方式，那么通道就是一种与Goroutine通信的方式。通道让数据能够进入和离开Goroutine，可方便Goutine之间进行通信。
 *
 * 	不要通过共享内存来通信，而通过通信来共享内存
 * 		这句话说明了Go语言并发实现方式的不同之处，这部分有必要做进一步解释。在其他编程语言中，并发编程通常是通过在多个进程或线程之间共享内存来实现的。共享内存能够让程序同步，确保程序
 * 	以合乎逻辑的方式执行。在程序执行过程中，进程和线程可能对共享内存加锁，以禁止其他进程或线程修改它。这合乎情理，因为如果在操作期间共享内存被其他进程修改，可能会带来灾难性后果--引发
 * 	Bug或导致程序崩溃。通过这种方式给内存加锁，可确保它是独占的--只有一个进程或线程能够访问它。
 * 		这听起来可能太过抽象，我们来看一个例子：两个人持有一个联名账户，他们要同时从这个账户支付费用，但这两笔交易的总额超过了账户余额。如果两个交易同时进行且不加锁，则余额检查可能表
 * 	明资金充足，但实际上资金不够；然而，如果第一个交易将账户加锁，则直到交易完成，都可避免这样的情况发生。对于简单的并发而言，这种方式看似合理，但如果联名账户有20个持有人，且他们经常
 * 	使用这个账户进行交易呢？在这种情况下，加锁管理工作可能非常复杂。
 * 		共享内存和锁的管理工作并非那么容易，很多编程语言要求程序员对内存和内存管理有深入认识。即便是久经杀场的程序员也会遇到这样的情况，即为找出进程或线程争用共享内存而引发的Bug
 * 	，需要花费数天时间。在使用共享内存的并发环境中，如果不能始终知道程序的哪部分将先更新数据，那么将难以推断其中发生的情况。
 * 		虽然使用共享内存有其用武之地，但Go语言使用通道在Goroutine之间收发消息，避免了使用共享内存。严格地说，Goroutine并不是线程，但您可以将其视为线程，因为它们能够以非阻塞的方
 * 	式执行代码。在前面关于两人持有一个联合账户的例子中，如果使用Goroutine，将在账户持有人之间打开一个通信通道，让他们能够通信并采取相应的措施。例如，一个交易可能向通道发送一条消息，
 * 	而通道可能限制后续交易或另一个账户持有人的行为。通过收发消息，使得能够以推送方式协调并发事件。事件发生时，可将触发的消息推送给接收者。使用共享内存时，程序必须检查共享内存。在变化
 * 	频繁的并发编程环境中，很多人都认为使用消息是一种更加的通信方式。
 *
 */
package main

import (
	"fmt"
	"time"
)

func slowFunc(c chan string) {
	time.Sleep(time.Second * 2)

	c <- "slowFunc finished"
}

func main() {
	//创建通道
	c := make(chan string)

	//程序并序执行，不影响后续代码执行
	go slowFunc(c)
	fmt.Println("aaa")

	//接收来字通道c的消息。这将阻塞进程直到收到消息为止，从而避免进程过早退出
	//不能关闭、我在等人拿东西，人来了后，拿到东西，好，我完成任务了， 这条语句堵塞了后续执行
	msg := <-c
	fmt.Println(msg)
}
